diff --git a/xbmc/application/Application.cpp b/xbmc/application/Application.cpp
index bf1feb6..020e9f4 100644
--- a/xbmc/application/Application.cpp
+++ b/xbmc/application/Application.cpp
@@ -445,11 +445,11 @@ bool CApplication::CreateGUI()
   m_frameMoveGuard.lock();
 
   const auto appPower = GetComponent<CApplicationPowerHandling>();
-  appPower->SetRenderGUI(true);
+  appPower->SetRenderGUI(false);
 
   auto windowSystems = KODI::WINDOWING::CWindowSystemFactory::GetWindowSystems();
 
-  const std::string& windowing = CServiceBroker::GetAppParams()->GetWindowing();
+  const std::string& windowing = "headless";
 
   if (!windowing.empty())
     windowSystems = {windowing};
@@ -587,9 +587,6 @@ bool CApplication::InitWindow(RESOLUTION res)
 
 bool CApplication::Initialize()
 {
-  m_pActiveAE->Start();
-  // restore AE's previous volume state
-
   const auto appVolume = GetComponent<CApplicationVolumeHandling>();
   const auto level = appVolume->GetVolumeRatio();
   const auto muted = appVolume->IsMuted();
@@ -669,15 +666,13 @@ bool CApplication::Initialize()
 
   const auto skinHandling = GetComponent<CApplicationSkinHandling>();
 
-  bool uiInitializationFinished = false;
+  bool uiInitializationFinished = true;
 
-  if (CServiceBroker::GetGUI()->GetWindowManager().Initialized())
+  if (true)
   {
     const auto settings = CServiceBroker::GetSettingsComponent()->GetSettings();
 
-    CServiceBroker::GetGUI()->GetWindowManager().CreateWindows();
-
-    skinHandling->m_confirmSkinChange = false;
+    skinHandling->m_confirmSkinChange = true;
 
     std::vector<AddonInfoPtr> incompatibleAddons;
     event.Reset();
@@ -700,8 +695,6 @@ bool CApplication::Initialize()
         iDots = 1;
         while (!event.Wait(1000ms))
         {
-          CServiceBroker::GetRenderSystem()->ShowSplash(std::string(iDots, ' ') + localizedStr +
-                                                        std::string(iDots, '.'));
           if (iDots == 3)
             iDots = 1;
           else
@@ -717,63 +710,7 @@ bool CApplication::Initialize()
       }
     }
 
-    // Start splashscreen and load skin
-    CServiceBroker::GetRenderSystem()->ShowSplash("");
-    skinHandling->m_confirmSkinChange = true;
-
-    auto setting = settings->GetSetting(CSettings::SETTING_LOOKANDFEEL_SKIN);
-    if (!setting)
-    {
-      CLog::Log(LOGFATAL, "Failed to load setting for: {}", CSettings::SETTING_LOOKANDFEEL_SKIN);
-      return false;
-    }
-
     CServiceBroker::RegisterTextureCache(std::make_shared<CTextureCache>());
-
-    std::string skinId = settings->GetString(CSettings::SETTING_LOOKANDFEEL_SKIN);
-    if (!skinHandling->LoadSkin(skinId))
-    {
-      CLog::Log(LOGERROR, "Failed to load skin '{}'", skinId);
-      std::string defaultSkin =
-          std::static_pointer_cast<const CSettingString>(setting)->GetDefault();
-      if (!skinHandling->LoadSkin(defaultSkin))
-      {
-        CLog::Log(LOGFATAL, "Default skin '{}' could not be loaded! Terminating..", defaultSkin);
-        return false;
-      }
-    }
-
-    // initialize splash window after splash screen disappears
-    // because we need a real window in the background which gets
-    // rendered while we load the main window or enter the master lock key
-    CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(WINDOW_SPLASH);
-
-    if (settings->GetBool(CSettings::SETTING_MASTERLOCK_STARTUPLOCK) &&
-        profileManager->GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
-        !profileManager->GetMasterProfile().getLockCode().empty())
-    {
-      g_passwordManager.CheckStartUpLock();
-    }
-
-    // check if we should use the login screen
-    if (profileManager->UsingLoginScreen())
-    {
-      CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(WINDOW_LOGIN_SCREEN);
-    }
-    else
-    {
-      // activate the configured start window
-      int firstWindow = g_SkinInfo->GetFirstWindow();
-      CServiceBroker::GetGUI()->GetWindowManager().ActivateWindow(firstWindow);
-
-      if (CServiceBroker::GetGUI()->GetWindowManager().IsWindowActive(WINDOW_STARTUP_ANIM))
-      {
-        CLog::Log(LOGWARNING, "CApplication::Initialize - startup.xml taints init process");
-      }
-
-      // the startup window is considered part of the initialization as it most likely switches to the final window
-      uiInitializationFinished = firstWindow != WINDOW_STARTUP_ANIM;
-    }
   }
   else //No GUI Created
   {
@@ -814,11 +751,6 @@ bool CApplication::Initialize()
 
   CLog::Log(LOGINFO, "initialize done");
 
-  const auto appPower = GetComponent<CApplicationPowerHandling>();
-  appPower->CheckOSScreenSaverInhibitionSetting();
-  // reset our screensaver (starts timers etc.)
-  appPower->ResetScreenSaver();
-
   // if the user interfaces has been fully initialized let everyone know
   if (uiInitializationFinished)
   {
diff --git a/xbmc/platform/linux/PlatformLinux.cpp b/xbmc/platform/linux/PlatformLinux.cpp
index a99ceef..dea8d1f 100644
--- a/xbmc/platform/linux/PlatformLinux.cpp
+++ b/xbmc/platform/linux/PlatformLinux.cpp
@@ -24,6 +24,7 @@
 #endif
 
 #include "platform/linux/powermanagement/LinuxPowerSyscall.h"
+#include "windowing/WinSystemHeadless.h"
 
 // clang-format off
 #if defined(HAS_GLES)
@@ -64,6 +65,7 @@ bool CPlatformLinux::InitStageOne()
     return false;
 
   setenv("OS", "Linux", true); // for python scripts that check the OS
+  CWinSystemHeadless::RegisterMe();
 
 #if defined(TARGET_WEBOS)
   // WebOS ipks run in a chroot like environment. $HOME is set to the ipk dir and $LD_LIBRARY_PATH is lib
diff --git a/xbmc/windowing/CMakeLists.txt b/xbmc/windowing/CMakeLists.txt
index 21c7611..1e58f1b 100644
--- a/xbmc/windowing/CMakeLists.txt
+++ b/xbmc/windowing/CMakeLists.txt
@@ -2,6 +2,7 @@ set(SOURCES GraphicContext.cpp
             OSScreenSaver.cpp
             Resolution.cpp
             WindowSystemFactory.cpp
+            WinSystemHeadless.cpp
             WinSystem.cpp)
 
 set(HEADERS GraphicContext.h
@@ -9,6 +10,7 @@ set(HEADERS GraphicContext.h
             Resolution.h
             WinEvents.h
             WindowSystemFactory.h
+            WinSystemHeadless.h
             WinSystem.h
             XBMC_events.h
             VideoSync.h)
diff --git a/xbmc/windowing/WinSystemHeadless.cpp b/xbmc/windowing/WinSystemHeadless.cpp
new file mode 100644
index 0000000..b3d7ae5
--- /dev/null
+++ b/xbmc/windowing/WinSystemHeadless.cpp
@@ -0,0 +1,69 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "WinSystemHeadless.h"
+
+#include "windowing/WindowSystemFactory.h"
+
+#include "utils/log.h"
+
+#include <vector>
+#include <string>
+
+//using namespace KODI::MESSAGING;
+using namespace KODI::WINDOWING;
+
+#define EGL_NO_CONFIG (EGLConfig)0
+
+void CWinSystemHeadless::RegisterMe()
+{
+  KODI::WINDOWING::CWindowSystemFactory::RegisterWindowSystem(CreateWinSystem, "headless");
+}
+
+std::unique_ptr<CWinSystemBase> CWinSystemHeadless::CreateWinSystem()
+{
+  return std::make_unique<CWinSystemHeadless>();
+}
+
+CWinSystemHeadless::CWinSystemHeadless() : CWinSystemBase(), CRenderSystemBase()
+{
+}
+
+CWinSystemHeadless::~CWinSystemHeadless() = default;
+
+// bool CWinSystemHeadless::MessagePump()
+// {
+//   return m_winEvents->MessagePump();
+// }
+
+bool CWinSystemHeadless::InitWindowSystem() {return true;};
+bool CWinSystemHeadless::DestroyWindowSystem() {return true;};
+bool CWinSystemHeadless::CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res) {return true;};
+bool CWinSystemHeadless::DestroyWindow() {return true;};
+bool CWinSystemHeadless::ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) {return true;};
+void CWinSystemHeadless::FinishWindowResize(int newWidth, int newHeight) {};
+bool CWinSystemHeadless::SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) {return true;};
+void CWinSystemHeadless::UpdateResolutions() {};
+void CWinSystemHeadless::ShowOSMouse(bool show) {};
+
+void CWinSystemHeadless::NotifyAppActiveChange(bool bActivated) {};
+void CWinSystemHeadless::NotifyAppFocusChange(bool bGaining) {};
+
+bool CWinSystemHeadless::Minimize() {return true;};
+bool CWinSystemHeadless::Restore() {return true;};
+bool CWinSystemHeadless::Hide() {return true;};
+bool CWinSystemHeadless::Show(bool raise) {return true;};
+void CWinSystemHeadless::Register(IDispResource *resource) {};
+void CWinSystemHeadless::Unregister(IDispResource *resource) {};
+bool CWinSystemHeadless::HasCalibration(const RESOLUTION_INFO &resInfo) {return true;};
+bool CWinSystemHeadless::UseLimitedColor() {return true;};
+
+void CWinSystemHeadless::ShowSplash(const std::string& message)
+{
+  CLog::Log(LOGDEBUG, message.c_str());
+};
diff --git a/xbmc/windowing/WinSystemHeadless.h b/xbmc/windowing/WinSystemHeadless.h
new file mode 100644
index 0000000..f15f571
--- /dev/null
+++ b/xbmc/windowing/WinSystemHeadless.h
@@ -0,0 +1,80 @@
+/*
+ *  Copyright (C) 2005-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#pragma once
+
+#include "rendering/RenderSystem.h"
+#include "WinSystem.h"
+
+#include <string>
+#include <vector>
+
+class CWinSystemHeadless : public CWinSystemBase, public CRenderSystemBase
+{
+public:
+  CWinSystemHeadless();
+  ~CWinSystemHeadless() override;
+
+  static void RegisterMe();
+  static std::unique_ptr<CWinSystemBase> CreateWinSystem();
+
+  // CWinSystemBase
+  CRenderSystemBase *GetRenderSystem() override { return this; }
+  bool InitWindowSystem() override;
+  bool DestroyWindowSystem() override;
+  bool CreateNewWindow(const std::string& name, bool fullScreen, RESOLUTION_INFO& res) override;
+  bool DestroyWindow() override;
+  bool ResizeWindow(int newWidth, int newHeight, int newLeft, int newTop) override;
+  void FinishWindowResize(int newWidth, int newHeight) override;
+  bool SetFullScreen(bool fullScreen, RESOLUTION_INFO& res, bool blankOtherDisplays) override;
+  void UpdateResolutions() override;
+  void ShowOSMouse(bool show) override;
+
+  void NotifyAppActiveChange(bool bActivated) override;
+  void NotifyAppFocusChange(bool bGaining) override;
+
+  bool Minimize() override;
+  bool Restore() override;
+  bool Hide() override;
+  bool Show(bool raise = true) override;
+  void Register(IDispResource *resource) override;
+  void Unregister(IDispResource *resource) override;
+  bool HasCalibration(const RESOLUTION_INFO &resInfo) override;
+  bool UseLimitedColor() override;
+
+  // winevents override
+  //bool MessagePump() override;
+
+  // render
+  bool InitRenderSystem() override { return true;} ;
+  bool DestroyRenderSystem() override { return true;} ;
+  bool ResetRenderSystem(int width, int height) override { return true;} ;
+
+  bool BeginRender() override { return true;} ;
+  bool EndRender() override { return true;} ;
+  void PresentRender(bool rendered, bool videoLayer) override {} ;
+  bool ClearBuffers(UTILS::COLOR::Color color) override { return true;} ;
+  bool IsExtSupported(const char* extension) const override { return false;} ;
+
+  void SetViewPort(const CRect& viewPort) override {} ;
+  void GetViewPort(CRect& viewPort) override {} ;
+
+  void SetScissors(const CRect &rect) override {} ;
+  void ResetScissors() override {} ;
+
+  void CaptureStateBlock() override {} ;
+  void ApplyStateBlock() override {} ;
+
+  void SetCameraPosition(const CPoint &camera, int screenWidth, int screenHeight, float stereoFactor = 0.f) override {} ;
+  void ShowSplash(const std::string& message) override;
+
+protected:
+
+private:
+
+};
